# Strategy

## 动机（Motivation）

+ 在软件构建过程中，某些对象使用的算法可能多种多样，经常改变，如果将这些算法都编码到对象中，将会使对象变得异常复杂；而且有时候支持不使用的算法也是一个性能负担。
+ 如何在运行时根据需要透明地更改对象的算法？将算法与对象本身解耦，从而避免上述问题？

## 模式定义

定义一系列算法，把它们一个个封装起来，并且使它们可互相替换（变化）。该模式使得算法可独立于使用它的客户程序(稳定)而变化（扩展，子类化）。
——《设计模式》 GoF

## 结构
    
![Strategy](./Strategy.png)

## 适用场合

1. 许多相关的类目的相同仅仅是『行为/方式/算法』不同。 『策略』可以提供多种不同的行为中的一
种，进行配置来达到相同的目的。

2. 需要使用一个算法的不同变体。 这些变体可能在时间/空间上需要权衡。

3. 算法使用客户不应该知道的数据。 使用策略模式可以避免暴露与算法相关的数据结构。

4. 一个类存在多种『行为』，这些行为在类的操作中多以多个**条件语句**的形式出现，则可以将
相关的条件分支移到册子的 Strategy 类中代替条件语句。

## 要点总结

+ Strategy及其子类为组件提供了一系列可重用的算法，从而可以使得类型在运行时方便地根据需要在各个算法之间进行切换。
+ Strategy模式提供了用条件判断语句以外的另一种选择，消除条件判断语句，就是在解耦合。含有许多条件判断语句的代码通常都需要Strategy模式。
+ 如果Strategy对象没有实例变量，那么各个上下文可以共享同一个Strategy对象，从而节省对象开销。


## 代码示例

[策略模式示例代码](./strategy2.cpp)

+   代码中 SalesOrder(Context) 类，聚合了 TaxStrategy(Strategy)，并且调用其接口计
    算税，使 SalesOrder(Context) 依赖于稳定的抽象类 TaxStrategy(Strategy)。
+   SalesOrder(Context) 中构造函数使用了 StrategyFactory 指针，使用工厂模式，使其
    依赖于工厂模式稳定部分从而保证了自己的稳定性，避免直接使用 TaxStrategy(Strategy)
    的具体类从而导致『硬编码』。
+   在扩展时候只需要扩展工厂模式部分即可。

![UML](./example.png)